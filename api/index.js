const express = require('express'); const mongoose = require('mongoose'); const jwt = require('jsonwebtoken'); const bcrypt = require('bcrypt'); const cloudinary = require('cloudinary').v2; const cors = require('cors'); const app = express(); app.use(express.json()); app.use(cors()); // Configurar Cloudinary cloudinary.config({ cloud_name: process.env.CLOUDINARY_CLOUD_NAME, api_key: process.env.CLOUDINARY_API_KEY, api_secret: process.env.CLOUDINARY_API_SECRET }); // Conectar a MongoDB mongoose.connect(process.env.MONGODB_URI, { useNewUrlParser: true, useUnifiedTopology: true }); // Modelos const User = mongoose.model('User', new mongoose.Schema({ username: String, password: String })); const Message = mongoose.model('Message', new mongoose.Schema({ text: String, user: String, date: { type: Date, default: Date.now } })); const Content = mongoose.model('Content', new mongoose.Schema({ section: String, text: String })); const Image = mongoose.model('Image', new mongoose.Schema({ url: String, description: String, date: { type: Date, default: Date.now } })); // Inicializar usuarios async function initUsers() { const users = [ { username: 'Julia', password: 'julia123' }, { username: 'David', password: 'david123' } ]; for (let user of users) { const exists = await User.findOne({ username: user.username }); if (!exists) { const hashed = await bcrypt.hash(user.password, 10); await new User({ username: user.username, password: hashed }).save(); } } } initUsers(); // Middleware de autenticaciÃ³n function authenticateToken(req, res, next) { const token = req.headers['authorization']; if (!token) return res.sendStatus(401); jwt.verify(token, process.env.JWT_SECRET, (err, user) => { if (err) return res.sendStatus(403); req.user = user; next(); }); } // Rutas app.post('/login', async (req, res) => { const { username, password } = req.body; const user = await User.findOne({ username }); if (!user || !(await bcrypt.compare(password, user.password))) { return res.status(401).json({ error: 'Invalid credentials' }); } const token = jwt.sign({ username: user.username }, process.env.JWT_SECRET); res.json({ token }); }); app.get('/messages', async (req, res) => { const messages = await Message.find().sort({ date: -1 }); res.json(messages); }); app.post('/messages', authenticateToken, async (req, res) => { const { text } = req.body; const message = new Message({ text, user: req.user.username }); await message.save(); res.json(message); }); app.get('/content', async (req, res) => { const content = await Content.find(); res.json(content); }); app.put('/content', authenticateToken, async (req, res) => { const { section, text } = req.body; await Content.updateOne({ section }, { text }, { upsert: true }); res.json({ success: true }); }); app.get('/images', async (req, res) => { const images = await Image.find().sort({ date: -1 }); res.json(images); }); app.post('/images', authenticateToken, async (req, res) => { const { imageBase64, description } = req.body; const result = await cloudinary.uploader.upload(imageBase64, { upload_preset: process.env.CLOUDINARY_UPLOAD_PRESET }); const image = new Image({ url: result.secure_url, description }); await image.save(); res.json(image); }); module.exports = app;